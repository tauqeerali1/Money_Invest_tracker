{"ast":null,"code":"/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\n\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\n\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\n\nfunction getAxisMap(element, _ref, _ref2) {\n  let {\n    x,\n    y\n  } = _ref;\n  let {\n    xAxisID,\n    yAxisID\n  } = _ref2;\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {\n      axisId: xAxisID\n    };\n  });\n  each(y, key => {\n    axisMap[key] = {\n      axisId: yAxisID\n    };\n  });\n  return axisMap;\n}\n\nconst cancelAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n\n  return window.cancelAnimationFrame;\n}();\n\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\n\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\n\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\n\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? {\n    value: scale.getPixelForValue(value),\n    transitionable: true\n  } : {\n    value: fallback\n  };\n}\n\nfunction updateBoxAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {\n        axisId: xScaleID\n      };\n    }\n\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {\n        axisId: xScaleID\n      };\n    }\n\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {\n        axisId: xScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {\n        axisId: yScaleID\n      };\n    }\n\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {\n        axisId: yScaleID\n      };\n    }\n\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {\n        axisId: yScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n}\n\nfunction updateLineAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    scaleID,\n    value\n  } = options;\n  const scale = scales[scaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {\n        axisId: scaleID\n      };\n      streaming[isHorizontal ? 'x2' : 'y2'] = {\n        axisId: scaleID\n      };\n    }\n\n    return isHorizontal ? {\n      top,\n      bottom\n    } : {\n      left,\n      right\n    };\n  }\n\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n\n    if (min.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.left = left;\n    }\n\n    if (max.transitionable) {\n      streaming.x2 = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.right = right;\n    }\n  }\n\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n\n    if (min.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.top = top;\n    }\n\n    if (max.transitionable) {\n      streaming.y2 = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n\n  return clip;\n}\n\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {\n    xScaleID,\n    yScaleID,\n    xValue,\n    yValue\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n\n    if (x.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    }\n  }\n\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n\n    if (y.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    }\n  }\n}\n\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n\n  BoxAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n\n  LineAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n\n  PointAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\n\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n\n      afterUpdate.call(this, _chart, args, options);\n\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\n\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n\n  if (plugin) {\n    const state = plugin._getState(chart);\n\n    return state && state.elements || [];\n  }\n\n  return [];\n}\n\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\n\nconst transitionKeys$1 = {\n  x: ['x', 'caretX'],\n  y: ['y', 'caretY']\n};\n\nfunction update$1() {\n  const me = this;\n  const element = me.getActiveElements()[0];\n\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  me.constructor.prototype.update.call(me, ...args);\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n\n  if (!state) {\n    state = {\n      originalScaleOptions: {}\n    };\n    chartStates.set(chart, state);\n  }\n\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction storeOriginalScaleOptions(chart) {\n  const {\n    originalScaleOptions\n  } = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\n\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDuration = 0,\n    maxDuration = Infinity,\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\n\nfunction panRealTimeScale(scale, delta, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\n\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\n\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\n\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n\n    streaming.zoomPlugin = plugin;\n  }\n}\n\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\n\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\n\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {\n    size: milliseconds,\n    steps\n  } = INTERVALS[unit];\n  let factor;\n\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n\n  return factor;\n}\n\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {\n      common,\n      size,\n      steps\n    } = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {\n      lo,\n      hi\n    } = _lookup(timestamps, time);\n\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\nconst datasetPropertyKeys = ['pointBackgroundColor', 'pointBorderColor', 'pointBorderWidth', 'pointRadius', 'pointRotation', 'pointStyle', 'pointHitRadius', 'pointHoverBackgroundColor', 'pointHoverBorderColor', 'pointHoverBorderWidth', 'pointHoverRadius', 'backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'radius', 'rotation'];\n\nfunction clean(scale) {\n  const {\n    chart,\n    id,\n    max\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n\n      count = i - start;\n\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\n\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\n\nfunction scroll(scale) {\n  const {\n    chart,\n    id,\n    $realtime: realtime\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {\n      data: elements = [],\n      dataset: element\n    } = meta;\n\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\n\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {\n      $realtime: realtime,\n      options\n    } = me;\n    const {\n      bounds,\n      offset,\n      ticks: ticksOpts\n    } = options;\n    const {\n      autoSkip,\n      source,\n      major: majorTicksOpts\n    } = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n\n        return resolveOption(me, 'frameRate');\n      });\n    }\n\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n\n      me._handleMargins();\n    }\n  }\n\n  draw(chartArea) {\n    const me = this;\n    const {\n      chart,\n      ctx\n    } = me;\n    const area = me.isHorizontal() ? {\n      left: chartArea.left,\n      top: 0,\n      right: chartArea.right,\n      bottom: chart.height\n    } : {\n      left: 0,\n      top: chartArea.top,\n      right: chart.width,\n      bottom: chartArea.bottom\n    };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n\n    const capacity = me._getLabelCapacity(min);\n\n    const {\n      time: timeOpts,\n      ticks: ticksOpts\n    } = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    time = first;\n\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n\n}\n\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\nvar version = \"2.0.0\";\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {\n  x: ['x', 'cp1x', 'cp2x'],\n  y: ['y', 'cp1y', 'cp2y']\n};\n\nfunction update(mode) {\n  const me = this;\n\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n\n      controller._setStyle = function (element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n\n  Chart.prototype.update.call(me, mode);\n\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\n\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\n\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {\n      render\n    };\n    const canvas = streaming.canvas = chart.canvas;\n\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n\n  afterInit(chart) {\n    chart.update = update;\n  },\n\n  beforeUpdate(chart) {\n    const {\n      scales,\n      elements\n    } = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, _ref3 => {\n      let {\n        type\n      } = _ref3;\n\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n\n  beforeDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n\n    if (mode === 'quiet') {\n      const {\n        controller,\n        $animations\n      } = meta;\n\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n\n  afterDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n    const {\n      data: elements = [],\n      dataset: element,\n      controller\n    } = meta;\n\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n\n  beforeDatasetDraw(chart, args) {\n    const {\n      ctx,\n      chartArea,\n      width,\n      height\n    } = chart;\n    const {\n      xAxisID,\n      yAxisID,\n      controller\n    } = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n\n    clipArea(ctx, area);\n  },\n\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n\n  destroy(chart) {\n    const {\n      scales,\n      $streaming: streaming,\n      tooltip\n    } = chart;\n    const {\n      canvas,\n      mouseEventListener\n    } = streaming;\n    delete chart.update;\n\n    if (tooltip) {\n      delete tooltip.update;\n    }\n\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\nconst registerables = [StreamingPlugin, RealTimeScale];\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };","map":{"version":3,"sources":["/home/tauqeer/Downloads/React-Project/expense_tracker/node_modules/chartjs-plugin-streaming/dist/chartjs-plugin-streaming.esm.js"],"names":["registry","TimeScale","defaults","DatasetController","Chart","valueOrDefault","each","requestAnimFrame","callback","noop","isFinite","clipArea","unclipArea","isNumber","_lookup","isArray","getRelativePosition","clamp","value","lower","upper","Math","min","max","resolveOption","scale","key","realtimeOpts","options","realtime","streamingOpts","chart","plugins","streaming","getAxisMap","element","x","y","xAxisID","yAxisID","axisMap","axisId","cancelAnimFrame","window","cancelAnimationFrame","startFrameRefreshTimer","context","func","frameRequestID","refresh","nextRefresh","now","Date","newFrameRate","frameDuration","newNextRefresh","call","stopFrameRefreshTimer","stopDataRefreshTimer","refreshTimerID","clearInterval","refreshInterval","startDataRefreshTimer","interval","setInterval","newInterval","isNaN","scaleValue","fallback","parse","getPixelForValue","transitionable","updateBoxAnnotation","scales","chartArea","xScaleID","yScaleID","xMin","xMax","yMin","yMax","xScale","yScale","top","left","bottom","right","$streaming","reverse","width","height","updateLineAnnotation","scaleID","isHorizontal","pixel","clip","x2","y2","updatePointAnnotation","xValue","yValue","initAnnotationPlugin","BoxAnnotation","getElement","LineAnnotation","PointAnnotation","resolveBoxAnnotationProperties","prototype","resolveElementProperties","resolveLineAnnotationProperties","resolvePointAnnotationProperties","properties","attachChart$1","plugin","annotationPlugin","afterUpdate","_chart","args","mode","animationOpts","animation","getElements","state","_getState","elements","detachChart$1","transitionKeys$1","update$1","me","getActiveElements","meta","getDatasetMeta","datasetIndex","constructor","update","chartStates","WeakMap","getState","get","originalScaleOptions","set","removeState","delete","storeOriginalScaleOptions","id","duration","delay","opt","zoomRealTimeScale","zoom","center","limits","axis","minDuration","maxDuration","Infinity","minDelay","maxDelay","newDuration","maxPercent","newDelay","panRealTimeScale","delta","getValueForPixel","resetRealTimeScaleOptions","realtimeOptions","original","initZoomPlugin","zoomFunctions","panFunctions","attachChart","zoomPlugin","resetZoom","transition","detachChart","INTERVALS","millisecond","common","size","steps","second","minute","hour","day","week","month","quarter","year","UNITS","Object","keys","determineStepSize","unit","capacity","range","milliseconds","factor","ceil","i","ilen","length","determineUnitForAutoTicks","minUnit","indexOf","Number","MAX_SAFE_INTEGER","determineMajorUnit","addTick","ticks","time","timestamps","lo","hi","timestamp","datasetPropertyKeys","clean","ttl","pause","start","count","removalRange","data","datasets","dataset","controller","point","getParsed","splice","datalabels","_active","item","index","labels","translate","animations","$animations","_from","_to","scroll","$realtime","tooltip","annotations","offset","head","_path","RealTimeScale","props","init","scaleOpts","opts","onRefresh","maxWidth","maxHeight","margins","bounds","ticksOpts","autoSkip","source","major","majorTicksOpts","majorEnabled","enabled","render","undefined","buildTicks","maxArray","minArray","defineProperty","shift","calculateLabelRotation","maxRotation","minRotation","fit","display","paddingLeft","paddingRight","_handleMargins","draw","ctx","area","_gridLineItems","_labelItems","destroy","_generate","adapter","_adapter","_getLabelCapacity","timeOpts","minor","stepSize","weekday","isoWeekday","majorTicksEnabled","hasWeekday","first","startOf","diff","Error","round","add","getDataTimestamps","sort","a","b","map","adapters","parser","displayFormats","describe","_scriptable","name","version","quiet","transitionKeys","_setStyle","_mode","active","lastMouseEvent","setTimeout","_eventHandler","StreamingPlugin","beforeInit","canvas","mouseEventListener","event","pos","type","native","addEventListener","afterInit","beforeUpdate","line","capBezierPoints","getPlugin","e","beforeDatasetUpdate","visible","updateElement","updateSharedOptions","afterDatasetUpdate","beforeDatasetDraw","getScaleForId","afterDatasetDraw","beforeEvent","removeEventListener","frameRate","descriptors","registerables"],"mappings":"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","sourcesContent":["/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\n\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\nfunction getAxisMap(element, {x, y}, {xAxisID, yAxisID}) {\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {axisId: xAxisID};\n  });\n  each(y, key => {\n    axisMap[key] = {axisId: yAxisID};\n  });\n  return axisMap;\n}\nconst cancelAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n  return window.cancelAnimationFrame;\n}());\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ?\n    {value: scale.getPixelForValue(value), transitionable: true} :\n    {value: fallback};\n}\nfunction updateBoxAnnotation(element, chart, options) {\n  const {scales, chartArea} = chart;\n  const {xScaleID, yScaleID, xMin, xMax, yMin, yMax} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {top, left, bottom, right} = chartArea;\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {axisId: xScaleID};\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {axisId: xScaleID};\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {axisId: xScaleID, reverse: min.transitionable};\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {axisId: yScaleID};\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {axisId: yScaleID};\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {axisId: yScaleID, reverse: min.transitionable};\n    }\n  }\n}\nfunction updateLineAnnotation(element, chart, options) {\n  const {scales, chartArea} = chart;\n  const {scaleID, value} = options;\n  const scale = scales[scaleID];\n  const {top, left, bottom, right} = chartArea;\n  const streaming = element.$streaming = {};\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {axisId: scaleID};\n      streaming[isHorizontal ? 'x2' : 'y2'] = {axisId: scaleID};\n    }\n    return isHorizontal ? {top, bottom} : {left, right};\n  }\n  const {xScaleID, yScaleID, xMin, xMax, yMin, yMax} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n    if (min.transitionable) {\n      streaming.x = {axisId: xScaleID};\n    } else {\n      clip.left = left;\n    }\n    if (max.transitionable) {\n      streaming.x2 = {axisId: xScaleID};\n    } else {\n      clip.right = right;\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n    if (min.transitionable) {\n      streaming.y = {axisId: yScaleID};\n    } else {\n      clip.top = top;\n    }\n    if (max.transitionable) {\n      streaming.y2 = {axisId: yScaleID};\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n  return clip;\n}\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {xScaleID, yScaleID, xValue, yValue} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n    if (x.transitionable) {\n      streaming.x = {axisId: xScaleID};\n    }\n  }\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n    if (y.transitionable) {\n      streaming.y = {axisId: yScaleID};\n    }\n  }\n}\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n  BoxAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n  LineAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n  PointAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n      afterUpdate.call(this, _chart, args, options);\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n  if (plugin) {\n    const state = plugin._getState(chart);\n    return state && state.elements || [];\n  }\n  return [];\n}\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\n\nconst transitionKeys$1 = {x: ['x', 'caretX'], y: ['y', 'caretY']};\nfunction update$1(...args) {\n  const me = this;\n  const element = me.getActiveElements()[0];\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n  me.constructor.prototype.update.call(me, ...args);\n}\n\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {originalScaleOptions: {}};\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction storeOriginalScaleOptions(chart) {\n  const {originalScaleOptions} = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {chart, axis} = scale;\n  const {minDuration = 0, maxDuration = Infinity, minDelay = -Infinity, maxDelay = Infinity} = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\nfunction panRealTimeScale(scale, delta, limits) {\n  const {chart, axis} = scale;\n  const {minDelay = -Infinity, maxDelay = Infinity} = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n    streaming.zoomPlugin = plugin;\n  }\n}\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\n\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {size: milliseconds, steps} = INTERVALS[unit];\n  let factor;\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n  return factor;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {common, size, steps} = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nconst datasetPropertyKeys = [\n  'pointBackgroundColor',\n  'pointBorderColor',\n  'pointBorderWidth',\n  'pointRadius',\n  'pointRotation',\n  'pointStyle',\n  'pointHitRadius',\n  'pointHoverBackgroundColor',\n  'pointHoverBorderColor',\n  'pointHoverBorderWidth',\n  'pointHoverRadius',\n  'backgroundColor',\n  'borderColor',\n  'borderSkipped',\n  'borderWidth',\n  'hoverBackgroundColor',\n  'hoverBorderColor',\n  'hoverBorderWidth',\n  'hoverRadius',\n  'hitRadius',\n  'radius',\n  'rotation'\n];\nfunction clean(scale) {\n  const {chart, id, max} = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n      count = i - start;\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\nfunction scroll(scale) {\n  const {chart, id, $realtime: realtime} = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {data: elements = [], dataset: element} = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {$realtime: realtime, options} = me;\n    const {bounds, offset, ticks: ticksOpts} = options;\n    const {autoSkip, source, major: majorTicksOpts} = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n        return resolveOption(me, 'frameRate');\n      });\n    }\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n      me._handleMargins();\n    }\n  }\n  draw(chartArea) {\n    const me = this;\n    const {chart, ctx} = me;\n    const area = me.isHorizontal() ?\n      {\n        left: chartArea.left,\n        top: 0,\n        right: chartArea.right,\n        bottom: chart.height\n      } : {\n        left: 0,\n        top: chartArea.top,\n        right: chart.width,\n        bottom: chartArea.bottom\n      };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const capacity = me._getLabelCapacity(min);\n    const {time: timeOpts, ticks: ticksOpts} = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    time = first;\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n}\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\n\nvar version = \"2.0.0\";\n\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {x: ['x', 'cp1x', 'cp2x'], y: ['y', 'cp1y', 'cp2y']};\nfunction update(mode) {\n  const me = this;\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n      controller._setStyle = function(element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n  Chart.prototype.update.call(me, mode);\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {render};\n    const canvas = streaming.canvas = chart.canvas;\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n  afterInit(chart) {\n    chart.update = update;\n  },\n  beforeUpdate(chart) {\n    const {scales, elements} = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, ({type}) => {\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n  beforeDatasetUpdate(chart, args) {\n    const {meta, mode} = args;\n    if (mode === 'quiet') {\n      const {controller, $animations} = meta;\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n  afterDatasetUpdate(chart, args) {\n    const {meta, mode} = args;\n    const {data: elements = [], dataset: element, controller} = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n  beforeDatasetDraw(chart, args) {\n    const {ctx, chartArea, width, height} = chart;\n    const {xAxisID, yAxisID, controller} = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n    clipArea(ctx, area);\n  },\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n  destroy(chart) {\n    const {scales, $streaming: streaming, tooltip} = chart;\n    const {canvas, mouseEventListener} = streaming;\n    delete chart.update;\n    if (tooltip) {\n      delete tooltip.update;\n    }\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\n\nconst registerables = [StreamingPlugin, RealTimeScale];\n\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };\n"]},"metadata":{},"sourceType":"module"}